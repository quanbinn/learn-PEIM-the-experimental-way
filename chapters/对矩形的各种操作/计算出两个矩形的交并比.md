# 计算出两个矩形的交并比

## 开始做实体实验

- 单机右方的[Jupyter Notebook](https://mybinder.org/v2/gh/ipython/ipython-in-depth/master?filepath=binder/Index.ipynb)，稍后在浏览器里会显示Jupyter Notebook的运行环境。
- 在File的第一个下拉菜单“New Notebook” 的右侧箭头处选择“Python 3”，然后会显示一个新的页面
- 把下面的这段python代码拷贝到这个页面“In [ ]:”右侧的空白栏中， 然后单击上方的按键“运行”。

### 在线调试环境2

- 单机右方的[Python Online Compiler](https://trinket.io/python3/a5bd54189b)，稍后在浏览器里会显示python的运行环境。
- 把下面的这段python代码拷贝到这个页面左侧的空白栏中， 然后单击上方的按键“Run”。

![](/images/对矩形的各种操作/计算出两个矩形的交并比/1a1.jpg)

```python
import matplotlib.pyplot as plt
import numpy as np 

class Rectangle:
    def __init__(self, x, y, width, height):
        self.x1 = x
        self.y1 = y
        self.x2 = x + width
        self.y2 = y + height
        self.width = width
        self.height = height            
    
    def getx1(self): return self.x1
    def gety1(self): return self.y1
    def getx2(self): return self.x2
    def gety2(self): return self.y2
    def getWidth(self): return self.width
    def getHeight(self): return self.height

    def area(self):
        area = self.width * self.height
        return area

    def centralCoordinates(self):
        x_of_center = (self.x1 + self.x2) / 2
        y_of_Center = (self.y1 + self.y2) / 2
        centralCoordinates = [x_of_center, y_of_Center]
        return centralCoordinates

    def render(self):
        p1 = [self.x1, self.y1]
        p2 = [self.x1 + self.width, self.y1] 
        p3 = [self.x1 + self.width, self.y1 + self.height]
        p4 = [self.x1, self.y1 + self.height]
        
        plt.plot([p1[0], p2[0]],[p1[1], p2[1]],color="green")
        plt.plot([p2[0], p3[0]],[p2[1], p3[1]],color="green")
        plt.plot([p3[0], p4[0]],[p3[1], p4[1]],color="green")
        plt.plot([p4[0], p1[0]],[p4[1], p1[1]],color="green")   

rect1 = Rectangle(2,8,11,8)
rect1.render()

rect2 = Rectangle(0,3,11,8)
rect2.render()

def box_iou_xyxy(box1, box2):
    x1min, y1min, x1max, y1max = box1[0], box1[1], box1[2], box1[3]
    s1 = (y1max - y1min) * (x1max - x1min)

    x2min, y2min, x2max, y2max = box2[0], box2[1], box2[2], box2[3]
    s2 = (y2max - y2min) * (x2max - x2min)
    
    xmin = np.maximum(x1min, x2min)
    ymin = np.maximum(y1min, y2min)
    xmax = np.minimum(x1max, x2max)
    ymax = np.minimum(y1max, y2max)

    inter_h = np.maximum(ymax - ymin, 0.)
    inter_w = np.maximum(xmax - xmin, 0.)
    intersection = inter_h * inter_w
    union = s1 + s2 - intersection
    iou = intersection / union

    return iou

box1 = [rect1.getx1(), rect1.gety1(), rect1.getx2(), rect1.gety2()]
box2 = [rect2.getx1(), rect2.gety1(), rect2.getx2(), rect2.gety2()]
iou = box_iou_xyxy(box1, box2)
print('IoU is ',iou)
```

## 参考文献及资料

1. 维基百科
	- [Jaccard index](https://en.wikipedia.org/wiki/Jaccard_index) | [雅卡尔指数](https://zh.wikipedia.org/wiki/%E9%9B%85%E5%8D%A1%E5%B0%94%E6%8C%87%E6%95%B0) 

2. [交并比](https://paddlepedia.readthedocs.io/en/latest/tutorials/computer_vision/object_detection/IOU.html) 
	